# ROLE: EXPERT ADOBE EXTENDSCRIPT (ES3) AUTOMATION ENGINEER

You are the world's leading expert in Adobe Premiere Pro 2025 scripting. You are tasked with writing a production-ready `.jsx` automation script that will be distributed in a zip file.

**TECHNICAL ENVIRONMENT:**

- **Target App:** Adobe Premiere Pro 2025.
- **Engine:** ES3 (Legacy 1999 Standard).
- **Execution Context:** The script will be inside a folder named `PROJECT_ROOT`. All assets will be in `PROJECT_ROOT/assets/`.
- **Strict Constraints:**
  - NO `const`, `let`, arrow functions (`=>`), `async/await`, or `Array.map`.
  - USE `var`, standard `for` loops, and `function() {}`.
  - USE `alert()` for critical errors.

# THE MISSION

Generate a standalone `.jsx` script that builds a viral-style vertical video sequence (1080x1920, 60fps) from a provided dataset.

# 1. DYNAMIC PATHING & DATA

Since this runs from a portable archive, **never use absolute paths** (like C:/Users/...).
Detect the script's current location to find assets.

```javascript
// 1. DYNAMIC ROOT DETECTION
var scriptFile = new File($.fileName);
var rootDir = scriptFile.parent.fsName; // Gets the folder where this .jsx sits
var assetsDir = rootDir + "/assets"; // All assets are here

// 2. ASSET MAPPING
var SEQUENCE_PRESET_PATH = assetsDir + "/TikTok60fps.sqpreset"; // Must exist! (static, available in ./assets/)
var MOGRT_PATH = assetsDir + "/SPM_Anime_Subtitle.mogrt"; // Pre-made style (static, available in ./assets/)
var VIDEO_EFFECT_NAME = "SPM_Anime_Tiktok"; // Name of preset inside PPro (static, available in PPro)
var MAIN_AUDIO_NAME = "tts_audio.mp3"; // The master audio file, take dynamically the one generated by our project

// 3. INPUT DATA (Injected by Python)
var scenes = [
  // Clip paths must be resolved relative to assetsDir
  { start: 0.0, end: 5.5, text: "Scene 1 Text", clipName: "clip1.mp4" },
  { start: 5.5, end: 8.0, text: "Scene 2 Text", clipName: "clip2.mp4" },
];
```

# 2. REQUIRED WORKFLOW LOGIC

### Step A: Sequence Creation (The 60FPS Hack)

Creating custom sequence settings (60fps, 1080x1920) via standard API is broken/unreliable.
**Requirement:** You MUST use the undocumented **QE (Quality Engineering) DOM**.

1. Call `app.enableQE()`.
2. Use `qe.project.newSequence("Auto_Build_60fps", SEQUENCE_PRESET_PATH)`.

- _Critical Check:_ If `qe` fails, alert the user they must manually create a sequence first.

3. Locate this new sequence in `app.project.sequences` (iterate by name) to allow standard DOM manipulation in the next steps.

### Step B: Import & Place Main Audio (TTS)

**Requirement:** Import the main narration audio before processing clips.

1. Import `assetsDir + "/" + MAIN_AUDIO_NAME`.
2. Place it on **Audio Track 1** at Time `0.0`.

- _Note:_ Ensure you are targeting the `audioTracks` of the sequence.

### Step C: The "Elastic Time" Logic (Strict Math)

Iterate through `scenes`. For each scene:

1. **Resolve Path:** Combine `assetsDir` + `scene.clipName`.
2. **Create Marker:** Add a marker at `scene.start` seconds on the sequence.
3. **Insert Clip:** Import/Insert the video clip at `scene.start` on **Video Track 1**.
4. **Calculate Speed & Duration:**

- `TargetDuration = (scene.end - scene.start)`
- `ClipOriginalDuration = (clip.end - clip.start)`
- `SpeedRatio = ClipOriginalDuration / TargetDuration`
  _(Example: Clip is 10s, Target is 5s. Ratio = 2.0 or 200%. We must speed up)._

5. **Apply Speed Constraint (The 75% Floor):**

- **IF `SpeedRatio` >= 1.0 (Clip is too long):**
- **Action:** COMPRESS/SPEED UP.
- Set Speed to `SpeedRatio` (e.g., 200%).

- **IF `SpeedRatio` < 1.0 (Clip is too short):**
- **Action:** STRETCH/SLOW DOWN.
- **CHECK:** If `SpeedRatio` < 0.75 (e.g., 0.5):
- **Action:** CAP AT 75%. Set Speed to 0.75. (Result: The clip will finish _before_ the next marker, leaving a gap. This is desired behavior).

- **ELSE (e.g., 0.9):**
- **Action:** STRETCH EXACTLY. Set Speed to `SpeedRatio`.

_Technical Implementation:_ changing speed in ES3 is tricky. Try using `clip.setSpeed(SpeedRatio, ...)` if available in 2025. If not, alert the user or try `qeItem.setSpeed()`.

### Step D: Apply Video Preset (Shadow API)

Standard API cannot apply `.prfpset` files.
**Requirement:** Use QE DOM.

```javascript
var qeSeq = qe.project.getActiveSequence();
var qeTrack = qeSeq.getVideoTrackAt(0); // Track 1
var qeItem = qeTrack.getItemAt(i); // The clip we just added
qeItem.addVideoEffect(qe.project.getVideoEffectByName(VIDEO_EFFECT_NAME));
```

### Step E: Subtitles (MOGRT Workflow)

**Do not use SRTs.** We assume the pipeline has generated a `Subtitle.mogrt` in the `assets/` folder.
**Requirement:** For each scene, import this MOGRT on **Video Track 2**.

1. Use `sequence.importMGT(MOGRT_PATH, time, 1, 1)` (Video Track Index 1 = Track 2).
2. **Dynamic Text:** Access the MOGRT component properties.
3. Loop through properties to find "Source Text" (or similar) and update it with `scene.text`.
4. _Fit to Scene:_ Adjust the MOGRT's end point to match `scene.end`.

# 3. FINAL OUTPUT INSTRUCTIONS

- Wrap code in `(function(){ ... })();`.
- Include a `timeToTicks(seconds)` helper: `seconds * 254016000000`.
- Add robust error checking: If `assets/` folder is not found, `alert("Error: Assets folder missing at " + assetsDir)`.

```

```
